[{"id":"5e977f49.dd5858","type":"tab","label":"Flow 1","disabled":true,"info":""},{"id":"64459d52.947e9c","type":"tab","label":"Flow 2","disabled":true,"info":""},{"id":"97abb4d9.1824a","type":"tab","label":"Pressao Consolidado","disabled":true,"info":""},{"id":"e487e3b8.5c15f8","type":"tab","label":"Pressao Consolidado","disabled":false,"info":""},{"id":"63d49573.cba69c","type":"websocket-listener","z":"","path":"/ws/dados","wholemsg":"false"},{"id":"9d9f17bc.46dd7","type":"websocket-listener","z":"","path":"/ws/dados","wholemsg":"false"},{"id":"1854acec.103653","type":"influxdb","z":"","hostname":"modec.automais.cloud","port":"8086","protocol":"http","database":"database","name":"MODEC","usetls":false,"tls":"","influxdbVersion":"2.0","url":"http://modec.automais.cloud:8086","timeout":"10","rejectUnauthorized":false},{"id":"da940e76.8f0f28","type":"debug","z":"5e977f49.dd5858","name":"","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":590,"y":140,"wires":[]},{"id":"e2df70a.66b171","type":"websocket out","z":"5e977f49.dd5858","name":"Dados Server","server":"9d9f17bc.46dd7","client":"","x":600,"y":200,"wires":[]},{"id":"5bbda78f.adf2d","type":"http in","z":"5e977f49.dd5858","name":"Relatorio","url":"/relatorio","method":"get","upload":false,"swaggerDoc":"","x":410,"y":640,"wires":[["304349f2.8085de"]]},{"id":"c45c2cab.d47bb","type":"http response","z":"5e977f49.dd5858","name":"Responde","statusCode":"","headers":{},"x":840,"y":680,"wires":[]},{"id":"304349f2.8085de","type":"template","z":"5e977f49.dd5858","name":"","field":"payload","fieldType":"msg","format":"handlebars","syntax":"mustache","template":"<!DOCTYPE html>\n<html lang=\"pt\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Relatório - Pressões</title>\n    \n    <!-- Biblioteca Chart.js e adaptador para datas -->\n    <script src=\"https://cdn.jsdelivr.net/npm/chart.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns\"></script>\n\n    <style>\n        body { font-family: Arial, sans-serif; text-align: center; }\n        h2 { margin-bottom: 5px; }\n        p { font-size: 18px; margin: 5px 0; }\n        canvas { max-width: 100%; margin-top: 20px; max-height: 300px; }\n        .controls { margin: 10px 0; }\n        .controls button { margin: 5px; padding: 10px; font-size: 16px; cursor: pointer; }\n        #tempoTotal { font-size: 18px; font-weight: bold; margin: 10px; }\n        .table-container { max-height: 300px; overflow-y: auto; margin-top: 20px; }\n        table { width: 100%; border-collapse: collapse; }\n        th, td { border: 1px solid black; padding: 8px; text-align: center; }\n        th { background-color: #f4f4f4; }\n    </style>\n</head>\n<body>\n    <h2>Dados de Pressão</h2>\n\n    <div class=\"controls\">\n        <button onclick=\"startReading()\">Iniciar Leitura</button>\n        <button onclick=\"pauseReading()\">Pausar Leitura</button>\n        <button onclick=\"stopReading()\">Parar e Exportar CSV</button>\n    </div>\n\n    <p>Pressão A: <span id=\"pressaoA\">--</span> bar</p>\n    <p>Pressão B: <span id=\"pressaoB\">--</span> bar</p>\n    <p>Pressão Geral: <span id=\"pressaoGeral\">--</span> bar</p>\n    <p id=\"tempoTotal\">Tempo Armazenado: 00:00:00</p>\n\n    <canvas id=\"grafico\"></canvas>\n\n    <div class=\"table-container\">\n        <table>\n            <thead>\n                <tr>\n                    <th>Tempo</th>\n                    <th>Pressão A (bar)</th>\n                    <th>Pressão B (bar)</th>\n                    <th>Pressão Geral (bar)</th>\n                </tr>\n            </thead>\n            <tbody id=\"historicoTabela\"></tbody>\n        </table>\n    </div>\n\n    <script>\n        const ws = new WebSocket(\"wss://\" + location.host + \"/red/ws/dados\");\n\n        let historicoDados = [];\n        let isReading = false;\n        let isPaused = false;\n        let tempoInicio = null;\n        let tempoTotal = 0;\n        let intervaloTempo;\n        let ultimaAtualizacao = Date.now();\n\n        let bufferA = [];\n        let bufferB = [];\n        let bufferGeral = [];\n\n        let ultimaPressaoA = null;\n        let ultimaPressaoB = null;\n        let ultimaPressaoGeral = null;\n\n        function formatarTempo(ms) {\n            const horas = Math.floor(ms / 3600000);\n            const minutos = Math.floor((ms % 3600000) / 60000);\n            const segundos = Math.floor((ms % 60000) / 1000);\n            return `${String(horas).padStart(2, '0')}:${String(minutos).padStart(2, '0')}:${String(segundos).padStart(2, '0')}`;\n        }\n\n        const ctx = document.getElementById(\"grafico\").getContext(\"2d\");\n        const chart = new Chart(ctx, {\n            type: \"line\",\n            data: {\n                labels: [],\n                datasets: [\n                    { label: \"Pressão A (bar)\", data: [], borderColor: \"red\", fill: false },\n                    { label: \"Pressão B (bar)\", data: [], borderColor: \"blue\", fill: false },\n                    { label: \"Pressão Geral (bar)\", data: [], borderColor: \"green\", fill: false }\n                ]\n            },\n            options: {\n                responsive: true,\n                scales: {\n                    x: { type: \"time\", time: { unit: \"second\" }, title: { display: true, text: \"Tempo\" } },\n                    y: { title: { display: true, text: \"Pressão (bar)\" } }\n                }\n            }\n        });\n\n        function atualizarDados(mediaA, mediaB, mediaGeral, timestamp) {\n            historicoDados.push({ timestamp, pressaoA: mediaA, pressaoB: mediaB, pressaoGeral: mediaGeral });\n\n            if (historicoDados.length > 900) historicoDados.shift();\n\n            chart.data.labels.push(timestamp);\n            chart.data.datasets[0].data.push({ x: timestamp, y: mediaA });\n            chart.data.datasets[1].data.push({ x: timestamp, y: mediaB });\n            chart.data.datasets[2].data.push({ x: timestamp, y: mediaGeral });\n\n            if (chart.data.labels.length > 50) {\n                chart.data.labels.shift();\n                chart.data.datasets.forEach(dataset => dataset.data.shift());\n            }\n\n            chart.update();\n            atualizarTabela();\n\n            ultimaPressaoA = mediaA;\n            ultimaPressaoB = mediaB;\n            ultimaPressaoGeral = mediaGeral;\n            ultimaAtualizacao = Date.now();\n        }\n\n        function verificarMudanca(valorA, valorB, valorGeral) {\n            return valorA !== ultimaPressaoA || \n                   valorB !== ultimaPressaoB || \n                   valorGeral !== ultimaPressaoGeral;\n        }\n\n        ws.onmessage = function (event) {\n            try {\n                const data = JSON.parse(event.data);\n\n                var tempA = Math.round(Number(data.PRESSAO_A.value) * 0.0225);\n                var tempB = Math.round(Number(data.PRESSAO_B.value) * 0.0225);\n                var tempPressao = Math.round(Number(data.PRESSAO_GERAL.value) * 0.0225);\n                \n                const pressaoA = tempA> 10?tempA:0;//Math.round(Number(data.PRESSAO_A.value) * 0.0225);\n                const pressaoB = tempB > 10 ? tempB:0;//Math.round(Number(data.PRESSAO_B.value) * 0.0225);\n                const pressaoGeral = tempPressao > 10 ? tempPressao : 0;//Math.round(Number(data.PRESSAO_GERAL.value) * 0.0225);\n                const timestamp = new Date(data.timestamp);\n\n                bufferA.push(pressaoA);\n                bufferB.push(pressaoB);\n                bufferGeral.push(pressaoGeral);\n\n                if (bufferA.length > 10) bufferA.shift();\n                if (bufferB.length > 10) bufferB.shift();\n                if (bufferGeral.length > 10) bufferGeral.shift();\n\n                const mediaA = Math.round(bufferA.reduce((sum, val) => sum + val, 0) / bufferA.length);\n                const mediaB = Math.round(bufferB.reduce((sum, val) => sum + val, 0) / bufferB.length);\n                const mediaGeral = Math.round(bufferGeral.reduce((sum, val) => sum + val, 0) / bufferGeral.length);\n\n                document.getElementById(\"pressaoA\").innerText = mediaA;\n                document.getElementById(\"pressaoB\").innerText = mediaB;\n                document.getElementById(\"pressaoGeral\").innerText = mediaGeral;\n\n                if (isReading && !isPaused) {\n                    const mudou = verificarMudanca(mediaA, mediaB, mediaGeral);\n                    const tempoPassado = Date.now() - ultimaAtualizacao;\n\n                    // Atualiza se houve mudança ou se passou 1 minuto desde a última atualização\n                    if (mudou || tempoPassado >= 60000) {\n                        atualizarDados(mediaA, mediaB, mediaGeral, timestamp);\n                    }\n                }\n            } catch (error) {\n                console.error(\"Erro ao processar os dados recebidos:\", error);\n            }\n        };\n\n        function startReading() {\n            if (!isReading) {\n                isReading = true;\n                isPaused = false;\n                tempoInicio = Date.now() - tempoTotal;\n                intervaloTempo = setInterval(() => {\n                    tempoTotal = Date.now() - tempoInicio;\n                    document.getElementById(\"tempoTotal\").innerText = `Tempo Armazenado: ${formatarTempo(tempoTotal)}`;\n                }, 1000);\n            } else {\n                isPaused = false;\n            }\n        }\n\n        function pauseReading() {\n            isPaused = true;\n            clearInterval(intervaloTempo);\n        }\n\n        function stopReading() {\n            isReading = false;\n            isPaused = false;\n            clearInterval(intervaloTempo);\n            tempoTotal = 0;\n            document.getElementById(\"tempoTotal\").innerText = `Tempo Armazenado: 00:00:00`;\n            exportarCSV();\n        }\n\n        function atualizarTabela() {\n            let tabela = document.getElementById(\"historicoTabela\");\n            tabela.innerHTML = \"\";\n            historicoDados.slice(-50).forEach(dado => {\n                let row = `<tr>\n                    <td>${new Date(dado.timestamp).toLocaleTimeString()}</td>\n                    <td>${Math.round(dado.pressaoA)}</td>\n                    <td>${Math.round(dado.pressaoB)}</td>\n                    <td>${Math.round(dado.pressaoGeral)}</td>\n                </tr>`;\n                tabela.innerHTML += row;\n            });\n        }\n\n        function exportarCSV() {\n            if (historicoDados.length === 0) return;\n\n            const headers = ['Data', 'Hora', 'Pressão A (bar)', 'Pressão B (bar)', 'Pressão Geral (bar)'];\n            const csvData = historicoDados.map(dado => {\n                const data = new Date(dado.timestamp);\n                return [\n                    data.toLocaleDateString('pt-BR'),\n                    data.toLocaleTimeString('pt-BR'),\n                    dado.pressaoA,\n                    dado.pressaoB,\n                    dado.pressaoGeral\n                ];\n            });\n\n            // Add BOM for UTF-8\n            const BOM = '\\uFEFF';\n            const csvContent = BOM + \n                headers.join(',') + '\\r\\n' + \n                csvData.map(row => row.join(',')).join('\\r\\n');\n\n            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n            const link = document.createElement('a');\n            const url = URL.createObjectURL(blob);\n            \n            link.setAttribute('href', url);\n            link.setAttribute('download', `pressoes_${new Date().toISOString().slice(0,19).replace(/[:]/g, '-')}.csv`);\n            link.style.visibility = 'hidden';\n            \n            document.body.appendChild(link);\n            link.click();\n            document.body.removeChild(link);\n        }\n    </script>\n</body>\n</html>","output":"str","x":630,"y":680,"wires":[["c45c2cab.d47bb"]]},{"id":"b594f392.5ab6e","type":"influxdb out","z":"5e977f49.dd5858","influxdb":"1854acec.103653","name":"MODEC","measurement":"","precision":"","retentionPolicy":"","database":"database","precisionV18FluxV20":"s","retentionPolicyV18Flux":"","org":"datamais","bucket":"sensores","x":760,"y":260,"wires":[]},{"id":"7fba4316.0dc974","type":"function","z":"5e977f49.dd5858","name":"","func":"const payload = msg.payload;\n\nmsg.measurement = \"pressao\";  // <-- adiciona isso\n\nmsg.payload = {\n    tags: {\n        device: \"plc01\"\n    },\n    fields: {\n        PRESSAO_A:     parseInt(payload.PRESSAO_A.value),\n        PRESSAO_B:     parseInt(payload.PRESSAO_B.value),\n        PRESSAO_GERAL: parseInt(payload.PRESSAO_GERAL.value)\n    },\n    timestamp: new Date(payload.timestamp)\n};\n\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":580,"y":260,"wires":[["b594f392.5ab6e"]]},{"id":"315e92f.12b40ee","type":"uc-iodataIn","z":"64459d52.947e9c","mode":"wi_single_variable","variable":"PRESSAO_A","name":"","pollInterval":"200000","pollIntervalBase":"s","x":220,"y":80,"wires":[["f961d054.1504c"],[]]},{"id":"f961d054.1504c","type":"function","z":"64459d52.947e9c","name":"Média","func":"// =============================================\n// CONFIGURAÇÃO\nconst NUM_AMOSTRAS = 10; // altere aqui\n// =============================================\n\nlet buffer  = context.get('bufferA')  || [];\nlet pointer = context.get('pointerA') || 0;\n\nconst valor = parseFloat(msg.payload.value);\n\n// Preenche ou substitui no ponteiro atual\nif (buffer.length < NUM_AMOSTRAS) {\n    buffer.push(valor);\n} else {\n    buffer[pointer] = valor;\n}\n\n// Avança ponteiro (rotação)\npointer = (pointer + 1) % NUM_AMOSTRAS;\n\n// Trunca o buffer para NUM_AMOSTRAS (garante tamanho correto sempre)\nbuffer = buffer.slice(0, NUM_AMOSTRAS);\n\n// Calcula média APENAS sobre os itens do buffer\nconst media = buffer.reduce((acc, v) => acc + v, 0) / buffer.length;\n\n// Salva estado\ncontext.set('bufferA',  buffer);\ncontext.set('pointerA', pointer);\n\n// Saída\nmsg.payload = {\n    measurement: \"pressao_media\",\n    tags: {\n        name: msg.payload.name\n    },\n    fields: {\n        media:    parseFloat(media.toFixed(2)),\n        atual:    valor,\n        amostras: buffer.length,\n        buffer:   JSON.stringify(buffer)\n    },\n    timestamp: new Date(msg.payload.timestamp)\n};\n\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":490,"y":80,"wires":[["93a706f7.cd56c"]]},{"id":"93a706f7.cd56c","type":"function","z":"64459d52.947e9c","name":"Conversão","func":"// =============================================\n// CONFIGURAÇÃO DE ESCALA\nconst X1 = 764;        // valor bruto mínimo\nconst X2 = 8478;    // valor bruto máximo\nconst Y1 = 15;        // valor real mínimo (ex: 0 bar)\nconst Y2 = 195;      // valor real máximo (ex: 250 bar)\n// =============================================\n\nconst input = msg.payload.fields.media;  // <-- vem da função de média\n\nvar output = ((Y2 - Y1) / (X2 - X1)) * (input - X1) + Y1;\nif (output < 0) output = 0.0;\nmsg.payload = Math.round(output);//.fields.media_scaled = Math.round(output);\n//msg.payload.fields.unit = \"bar\";\n\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":690,"y":80,"wires":[["a575c635.56ba1","9e6132a3.5409e"]]},{"id":"941bec54.f010e","type":"uc-iodataIn","z":"64459d52.947e9c","mode":"wi_single_variable","variable":"PRESSAO_B","name":"","pollInterval":"200000","pollIntervalBase":"s","x":220,"y":160,"wires":[["8dfc5dc0.29378"],[]]},{"id":"8dfc5dc0.29378","type":"function","z":"64459d52.947e9c","name":"Média","func":"// =============================================\n// CONFIGURAÇÃO\nconst NUM_AMOSTRAS = 10; // altere aqui\n// =============================================\n\nlet buffer  = context.get('bufferB')  || [];\nlet pointer = context.get('pointerB') || 0;\n\nconst valor = parseFloat(msg.payload.value);\n\n// Preenche ou substitui no ponteiro atual\nif (buffer.length < NUM_AMOSTRAS) {\n    buffer.push(valor);\n} else {\n    buffer[pointer] = valor;\n}\n\n// Avança ponteiro (rotação)\npointer = (pointer + 1) % NUM_AMOSTRAS;\n\n// Trunca o buffer para NUM_AMOSTRAS (garante tamanho correto sempre)\nbuffer = buffer.slice(0, NUM_AMOSTRAS);\n\n// Calcula média APENAS sobre os itens do buffer\nconst media = buffer.reduce((acc, v) => acc + v, 0) / buffer.length;\n\n// Salva estado\ncontext.set('bufferB',  buffer);\ncontext.set('pointerB', pointer);\n\n// Saída\nmsg.payload = {\n    measurement: \"pressao_media\",\n    tags: {\n        name: msg.payload.name\n    },\n    fields: {\n        media:    parseFloat(media.toFixed(2)),\n        atual:    valor,\n        amostras: buffer.length,\n        buffer:   JSON.stringify(buffer)\n    },\n    timestamp: new Date(msg.payload.timestamp)\n};\n\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":490,"y":160,"wires":[["c5efacad.0005e"]]},{"id":"c5efacad.0005e","type":"function","z":"64459d52.947e9c","name":"Conversão","func":"// =============================================\n// CONFIGURAÇÃO DE ESCALA\nconst X1 = 764;        // valor bruto mínimo\nconst X2 = 8478;    // valor bruto máximo\nconst Y1 = 15;        // valor real mínimo (ex: 0 bar)\nconst Y2 = 195;      // valor real máximo (ex: 250 bar)\n// =============================================\n\nconst input = msg.payload.fields.media;  // <-- vem da função de média\n\nvar output = ((Y2 - Y1) / (X2 - X1)) * (input - X1) + Y1;\n\nif (output < 0) output = 0;\nmsg.payload = Math.round(output);\n\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":690,"y":160,"wires":[["b018d37a.03cf98"]]},{"id":"d8f6b6f2.4ff768","type":"uc-iodataIn","z":"64459d52.947e9c","mode":"wi_single_variable","variable":"PRESSAO_GERAL","name":"","pollInterval":"200000","pollIntervalBase":"s","x":220,"y":240,"wires":[["d2438b55.86394"],[]]},{"id":"d2438b55.86394","type":"function","z":"64459d52.947e9c","name":"Média","func":"// =============================================\n// CONFIGURAÇÃO\nconst NUM_AMOSTRAS = 10; // altere aqui\n// =============================================\n\nlet buffer  = context.get('bufferC')  || [];\nlet pointer = context.get('pointerC') || 0;\n\nconst valor = parseFloat(msg.payload.value);\n\n// Preenche ou substitui no ponteiro atual\nif (buffer.length < NUM_AMOSTRAS) {\n    buffer.push(valor);\n} else {\n    buffer[pointer] = valor;\n}\n\n// Avança ponteiro (rotação)\npointer = (pointer + 1) % NUM_AMOSTRAS;\n\n// Trunca o buffer para NUM_AMOSTRAS (garante tamanho correto sempre)\nbuffer = buffer.slice(0, NUM_AMOSTRAS);\n\n// Calcula média APENAS sobre os itens do buffer\nconst media = buffer.reduce((acc, v) => acc + v, 0) / buffer.length;\n\n// Salva estado\ncontext.set('bufferC',  buffer);\ncontext.set('pointerC', pointer);\n\n// Saída\nmsg.payload = {\n    measurement: \"pressao_media\",\n    tags: {\n        name: msg.payload.name\n    },\n    fields: {\n        media:    parseFloat(media.toFixed(2)),\n        atual:    valor,\n        amostras: buffer.length,\n        buffer:   JSON.stringify(buffer)\n    },\n    timestamp: new Date(msg.payload.timestamp)\n};\n\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":490,"y":240,"wires":[["61645cd7.521a54"]]},{"id":"61645cd7.521a54","type":"function","z":"64459d52.947e9c","name":"Conversão","func":"// =============================================\n// CONFIGURAÇÃO DE ESCALA\nconst X1 = 764;        // valor bruto mínimo\nconst X2 = 8478;    // valor bruto máximo\nconst Y1 = 15;        // valor real mínimo (ex: 0 bar)\nconst Y2 = 195;      // valor real máximo (ex: 250 bar)\n// =============================================\n\nconst input = msg.payload.fields.media;  // <-- vem da função de média\n\nvar output = ((Y2 - Y1) / (X2 - X1)) * (input - X1) + Y1;\nif (output < 0) output = 0;\n\nmsg.payload = Math.round(output);\n\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":690,"y":240,"wires":[["118de7df.653888"]]},{"id":"a575c635.56ba1","type":"uc-iodataOut","z":"64459d52.947e9c","mode":"wi_single_variable","variableId":"9a3d799a-b4db-42ba-821b-027bbb9b65e9","variableName":"PRESSAO_A_CONV","name":"","x":920,"y":80,"wires":[[]]},{"id":"b018d37a.03cf98","type":"uc-iodataOut","z":"64459d52.947e9c","mode":"wi_single_variable","variableId":"f9dcfd52-19d6-4d5d-b149-c4d20a314d7d","variableName":"PRESSAO_B_CONV","name":"","x":920,"y":160,"wires":[[]]},{"id":"118de7df.653888","type":"uc-iodataOut","z":"64459d52.947e9c","mode":"wi_single_variable","variableId":"7987bde6-47f3-4722-9f2a-8274cd97128c","variableName":"PRESSAO_GERAL_CONV","name":"","x":920,"y":240,"wires":[[]]},{"id":"9e6132a3.5409e","type":"debug","z":"64459d52.947e9c","name":"","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":860,"y":400,"wires":[]},{"id":"9a105a3a.e617","type":"debug","z":"5e977f49.dd5858","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":460,"y":100,"wires":[]},{"id":"e92287f5.e30948","type":"uc-iodataIn","z":"97abb4d9.1824a","mode":"wi_all_variables","variable":"OUTPUT_MAX","name":"Leitura Pressões","pollInterval":"100","pollIntervalBase":"ms","x":200,"y":120,"wires":[["69922252.51d934","f60ade41.adb448"],[]]},{"id":"69922252.51d934","type":"function","z":"97abb4d9.1824a","name":"Média + Escala","func":"// =============================================\n// CONFIGURAÇÃO\nconst NUM_AMOSTRAS = 10;\n\nconst ESCALAS = {\n    PRESSAO_A: {\n        X1: 764,  X2: 8478,\n        Y1: 15,   Y2: 195,\n        saida: 'PRESSAO_A_CONV'\n    },\n    PRESSAO_B: {\n        X1: 764,  X2: 8478,\n        Y1: 15,   Y2: 195,\n        saida: 'PRESSAO_B_CONV'\n    },\n    PRESSAO_GERAL: {\n        X1: 764,  X2: 8478,\n        Y1: 15,   Y2: 195,\n        saida: 'PRESSAO_GERAL_CONV'\n    }\n};\n// =============================================\n\nconst timestamp = msg.payload.timestamp;\n\n// Converte array indexado em objeto por nome\nconst dados = {};\nObject.values(msg.payload).forEach(item => {\n    if (item && item.name) dados[item.name] = item;\n});\n\nlet buffers  = context.get('buffers')  || {};\nlet pointers = context.get('pointers') || {};\n\nconst resultado = {};\n\nObject.entries(ESCALAS).forEach(([nome, cfg]) => {\n    const item = dados[nome];\n    if (!item) return;\n\n    let buffer  = (buffers[nome] || []).slice(0, NUM_AMOSTRAS);\n    let pointer = pointers[nome] || 0;\n\n    const valor = parseFloat(item.value);\n\n    if (buffer.length < NUM_AMOSTRAS) {\n        buffer.push(valor);\n    } else {\n        buffer[pointer] = valor;\n    }\n\n    pointer = (pointer + 1) % NUM_AMOSTRAS;\n    buffers[nome]  = buffer;\n    pointers[nome] = pointer;\n\n    const media = buffer.reduce((acc, v) => acc + v, 0) / buffer.length;\n\n    let scaled = ((cfg.Y2 - cfg.Y1) / (cfg.X2 - cfg.X1)) * (media - cfg.X1) + cfg.Y1;\n    if (scaled < 0) scaled = 0;\n\n    resultado[cfg.saida] = Math.round(scaled);\n});\n\ncontext.set('buffers',  buffers);\ncontext.set('pointers', pointers);\n\nmsg.payload = resultado;\n\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":450,"y":120,"wires":[["7cc0154a.d11154","dbbacc25.b10bc"]]},{"id":"7cc0154a.d11154","type":"uc-iodataOut","z":"97abb4d9.1824a","mode":"wi_multiple_variables","variableId":"","variableName":"","name":"Grava Pressões CONV","x":700,"y":100,"wires":[[]]},{"id":"dbbacc25.b10bc","type":"debug","z":"97abb4d9.1824a","name":"Debug Saída","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","statusVal":"","statusType":"auto","x":700,"y":160,"wires":[]},{"id":"f60ade41.adb448","type":"debug","z":"97abb4d9.1824a","name":"","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":680,"y":360,"wires":[]},{"id":"8f7868d.d568d18","type":"uc-iodataIn","z":"e487e3b8.5c15f8","mode":"wi_all_variables","variable":"SL_SOLENOIDE_B","name":"Leitura Pressões","pollInterval":"200","pollIntervalBase":"ms","x":200,"y":120,"wires":[["b27c3904.4ada58","b3e3f2c5.72dde"],[]]},{"id":"b27c3904.4ada58","type":"function","z":"e487e3b8.5c15f8","name":"Média + Escala + Limites","func":"// =============================================\n// CONFIGURAÇÃO\nconst NUM_AMOSTRAS = 10;\n\n// Conversão direta: bruto → engenharia (BAR)\nconst ESCALAS = {\n    PRESSAO_A: {\n        X1: 764,  X2: 8478,\n        Y1: 15,   Y2: 195,\n        saida: 'PRESSAO_A_CONV'\n    },\n    PRESSAO_B: {\n        X1: 764,  X2: 8478,\n        Y1: 15,   Y2: 195,\n        saida: 'PRESSAO_B_CONV'\n    },\n    PRESSAO_GERAL: {\n        X1: 764,  X2: 8478,\n        Y1: 15,   Y2: 195,\n        saida: 'PRESSAO_GERAL_CONV'\n    }\n};\n\n// Conversão inversa: engenharia (BAR) → bruto\nconst ESCALAS_INV = {\n    LIMITE_A: {\n        X1: 764,  X2: 8478,\n        Y1: 15,   Y2: 195,\n        saida: 'LIMITE_A_ENG'\n    },\n    LIMITE_B: {\n        X1: 764,  X2: 8478,\n        Y1: 15,   Y2: 195,\n        saida: 'LIMITE_B_ENG'\n    },\n    PRESSAO_CARGA: {\n        X1: 764,  X2: 8478,\n        Y1: 15,   Y2: 195,\n        saida: 'PRESSAO_CARGA_ENG'\n    }\n};\n// =============================================\n\n// Converte array indexado em objeto por nome\nconst dados = {};\nObject.values(msg.payload).forEach(item => {\n    if (item && item.name) dados[item.name] = item;\n});\n\nlet buffers  = context.get('buffers')  || {};\nlet pointers = context.get('pointers') || {};\n\nconst resultado = {};\n\n// Conversão direta com média\nObject.entries(ESCALAS).forEach(([nome, cfg]) => {\n    const item = dados[nome];\n    if (!item) return;\n\n    let buffer  = (buffers[nome] || []).slice(0, NUM_AMOSTRAS);\n    let pointer = pointers[nome] || 0;\n\n    const valor = parseFloat(item.value);\n\n    if (buffer.length < NUM_AMOSTRAS) {\n        buffer.push(valor);\n    } else {\n        buffer[pointer] = valor;\n    }\n\n    pointer = (pointer + 1) % NUM_AMOSTRAS;\n    buffers[nome]  = buffer;\n    pointers[nome] = pointer;\n\n    const media = buffer.reduce((acc, v) => acc + v, 0) / buffer.length;\n\n    let scaled = ((cfg.Y2 - cfg.Y1) / (cfg.X2 - cfg.X1)) * (media - cfg.X1) + cfg.Y1;\n    if (scaled < 0) scaled = 0;\n\n    resultado[cfg.saida] = Math.round(scaled);\n});\n\ncontext.set('buffers',  buffers);\ncontext.set('pointers', pointers);\n\n// Conversão inversa sem média (valor direto em BAR → bruto)\nObject.entries(ESCALAS_INV).forEach(([nome, cfg]) => {\n    const item = dados[nome];\n    if (!item) return;\n\n    const valorBar = parseFloat(item.value);\n\n    let raw = ((valorBar - cfg.Y1) / (cfg.Y2 - cfg.Y1)) * (cfg.X2 - cfg.X1) + cfg.X1;\n    //if (raw < cfg.X1) raw = cfg.X1;\n    //if (raw > cfg.X2) raw = cfg.X2;\n\n    resultado[cfg.saida] = Math.round(raw);\n});\n\nmsg.payload = resultado;\n\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":460,"y":120,"wires":[["e6bf6aab.70576","b3e3f2c5.72dde"]]},{"id":"e6bf6aab.70576","type":"uc-iodataOut","z":"e487e3b8.5c15f8","mode":"wi_multiple_variables","variableId":"","variableName":"","name":"Grava Pressões CONV","x":720,"y":100,"wires":[[]]},{"id":"b3e3f2c5.72dde","type":"debug","z":"e487e3b8.5c15f8","name":"Debug Saída","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","statusVal":"","statusType":"auto","x":720,"y":160,"wires":[]}]